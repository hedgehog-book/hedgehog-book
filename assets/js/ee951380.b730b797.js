"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1004],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return f}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var u=r.createContext({}),c=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(u.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},l=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,u=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),l=c(n),f=i,d=l["".concat(u,".").concat(f)]||l[f]||m[f]||o;return n?r.createElement(d,a(a({ref:t},p),{},{components:n})):r.createElement(d,a({ref:t},p))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=l;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s.mdxType="string"==typeof e?e:i,a[1]=s;for(var c=2;c<o;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}l.displayName="MDXCreateElement"},4298:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return u},default:function(){return f},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return m}});var r=n(7462),i=n(3366),o=(n(7294),n(3905)),a=["components"],s={},u=void 0,c={unversionedId:"Basic Operations/Greatest Common Divisor",id:"Basic Operations/Greatest Common Divisor",title:"Greatest Common Divisor",description:"gcd(input1 Number | any[] | Mat) : Number| Mat",source:"@site/math/Basic Operations/Greatest Common Divisor.mdx",sourceDirName:"Basic Operations",slug:"/Basic Operations/Greatest Common Divisor",permalink:"/math/Basic Operations/Greatest Common Divisor",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Dot Multiply",permalink:"/math/Basic Operations/Dot Multiply"},next:{title:"bounds",permalink:"/math/Basic Operations/bounds"}},p={},m=[{value:"<code>gcd(input1: Number | any[] | Mat, input2: Number | any[] | Mat) : Number| Mat</code>",id:"gcdinput1-number--any--mat-input2-number--any--mat--number-mat",level:4}],l={toc:m};function f(e){var t=e.components,n=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h4",{id:"gcdinput1-number--any--mat-input2-number--any--mat--number-mat"},(0,o.kt)("inlineCode",{parentName:"h4"},"gcd(input1: Number | any[] | Mat, input2: Number | any[] | Mat) : Number| Mat")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"param")," ",(0,o.kt)("inlineCode",{parentName:"p"},"input1")," - Note: input1 and input2 must be the same type UNLESS you input a list only. The first input is the first part of the pair of items you want to find the gcd of. This function can find the gcd of two integers, or two 2d or 1d JS array/Mat objects"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"param")," ",(0,o.kt)("inlineCode",{parentName:"p"},"input2")," The other part of the pair. Must be identical to type of input1. Is the item to find the gcd of, whether its two integers, or two matrices, or two lists. "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"returns:")," ",(0,o.kt)("inlineCode",{parentName:"p"},"Number | Mat")," - The greatest common divisor is returned as an integer for the cases of 2 integers, OR it returns a Mat with the gcd in each indice element-wise. For example, given two 2x2 matrices, it will find the gcd of a","[0][0]"," and b","[0][0]"," and put it into the return matrix indice ","[0][0]","."),(0,o.kt)("p",null,"This function is the greatest common divisor function. The greatest common divisor is well known, but to reiterate, it is the shared integer between 2 (or more) numbers, such that it divides both of the numbers, and there is no number that can divide them that is larger. I.e. the largest shared divisor. This function returns the gcd of two integers and on top of that, if given lists, it will return the gcd element-wise of each list indice. If given just a list, it will give the gcd of all elements in that list. An example is shown below that may clear this up. "),(0,o.kt)("iframe",{src:"https://hlab.app/s/docs/hbook_gcd",width:"100%",height:"500px"}))}f.isMDXComponent=!0}}]);