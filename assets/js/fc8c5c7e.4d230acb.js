"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9142],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return f}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=u(n),f=a,y=c["".concat(l,".").concat(f)]||c[f]||m[f]||i;return n?r.createElement(y,o(o({ref:t},p),{},{components:n})):r.createElement(y,o({ref:t},p))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var u=2;u<i;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},8675:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return f},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return m}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],s={},l=void 0,u={unversionedId:"Data/Fill Missing Data",id:"Data/Fill Missing Data",title:"Fill Missing Data",description:"fill_missing(input Number | any[] | Mat | Tensor, method any[] | Mat | Tensor",source:"@site/math/Data/Fill Missing Data.mdx",sourceDirName:"Data",slug:"/Data/Fill Missing Data",permalink:"/math/Data/Fill Missing Data",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Create Missing Data",permalink:"/math/Data/Create Missing Data"},next:{title:"Local Maxima",permalink:"/math/Data/Local Maxima"}},p={},m=[{value:"<code>fill_missing(input: any[] | Mat | Tensor, content: Number | any[] | Mat | Tensor, method: String) : any[] | Mat | Tensor</code>",id:"fill_missinginput-any--mat--tensor-content-number--any--mat--tensor-method-string--any--mat--tensor",level:4}],c={toc:m};function f(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h4",{id:"fill_missinginput-any--mat--tensor-content-number--any--mat--tensor-method-string--any--mat--tensor"},(0,i.kt)("inlineCode",{parentName:"h4"},"fill_missing(input: any[] | Mat | Tensor, content: Number | any[] | Mat | Tensor, method: String) : any[] | Mat | Tensor")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"param")," ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," - the data construct to fill the missing entries in  "),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"param")," ",(0,i.kt)("inlineCode",{parentName:"p"},"content")," - this is what gets filled in the missing entries. Can be a number constant, array, matrix or tensor. Default is '0'. Note that it can only be an array in certain cases."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"param")," ",(0,i.kt)("inlineCode",{parentName:"p"},"method"),' - either "constant" or "previous". Constant means using the constant from content. Previous means using the previous value in the input and if no previous value, then use the constant value. Defaults to "constant".'),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"returns:")," ",(0,i.kt)("inlineCode",{parentName:"p"},"any[] | Mat | Tensor")," - the input with the missing values filled"),(0,i.kt)("p",null,"This function is relatively simple - it fills the empty entries in an array, matrix, Mat or Tensor. However there are nuances to it. First, you can decide what it fills it with by setting the ",(0,i.kt)("inlineCode",{parentName:"p"},"content")," parameter. Do you want it to put in, say -1's for each missing entry? Or do you want it to put in a 2d matrix in each missing entry? (You would then have a larger matrix as a return value). There's also the ",(0,i.kt)("inlineCode",{parentName:"p"},"method")," parameter. Do you want to always fill missing entries with ",(0,i.kt)("inlineCode",{parentName:"p"},"content"),"? For example, every single missing entry gets filled by ",(0,i.kt)("inlineCode",{parentName:"p"},"content = -1"),"? Or do you want to set ",(0,i.kt)("inlineCode",{parentName:"p"},'method = "previous"')," so that the missing entry uses the previous value of ",(0,i.kt)("inlineCode",{parentName:"p"},"input"),"?"),(0,i.kt)("p",null,"Below are some examples of various usages of the parameters:"),(0,i.kt)("iframe",{src:"https://hlab.app/s/docs/fill_missing_hbook",width:"100%",height:"500px"}))}f.isMDXComponent=!0}}]);